#!/usr/bin/env node
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { CallToolRequestSchema, ListToolsRequestSchema } from "@modelcontextprotocol/sdk/types.js";
import fs from 'fs/promises';
import path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);
const SUMMARY_DIR = path.join(process.cwd(), 'task-summaries');

// Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ Ð´Ð¸Ñ€ÐµÐºÑ‚Ð¾Ñ€Ð¸Ð¸ Ð´Ð»Ñ summaries
async function initSummaryDir() {
  try {
    await fs.mkdir(SUMMARY_DIR, { recursive: true });
  } catch (error) {
    console.error("âŒ Failed to create summary directory:", error.message);
  }
}

// Ð“ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ñ Markdown summary Ð¸Ð· Ð·Ð°Ð´Ð°Ñ‡
async function generateMarkdownSummary(tasksData) {
  const { tasks = [] } = tasksData;
  
  const todoTasks = tasks.filter(t => t.status === 'todo');
  const inProgressTasks = tasks.filter(t => t.status === 'in-progress');
  const doneTasks = tasks.filter(t => t.status === 'done');

  const timestamp = new Date().toISOString();
  const summary = `# ðŸ“‹ Task Summary Report

**Generated:** ${timestamp}  
**Total Tasks:** ${tasks.length}  
**Active:** ${todoTasks.length + inProgressTasks.length}  
**Completed:** ${doneTasks.length}

---

## ðŸ”´ TODO (${todoTasks.length})

${todoTasks.length === 0 
  ? '_No tasks in TODO_' 
  : todoTasks.map((t, i) => `${i + 1}. **[${t.priority.toUpperCase()}]** ${t.title}
   - ID: \`${t.id}\`
   - Created: ${new Date(t.createdAt).toLocaleDateString('ru-RU')}
   - Description: ${t.description || '_none_'}`).join('\n\n')}

---

## ðŸŸ¡ IN PROGRESS (${inProgressTasks.length})

${inProgressTasks.length === 0 
  ? '_No tasks in progress_' 
  : inProgressTasks.map((t, i) => `${i + 1}. **[${t.priority.toUpperCase()}]** ${t.title}
   - ID: \`${t.id}\`
   - Created: ${new Date(t.createdAt).toLocaleDateString('ru-RU')}
   - Description: ${t.description || '_none_'}`).join('\n\n')}

---

## ðŸŸ¢ DONE (${doneTasks.length})

${doneTasks.length === 0 
  ? '_No completed tasks_' 
  : doneTasks.map((t, i) => `${i + 1}. **${t.title}**
   - ID: \`${t.id}\`
   - Completed on: ${new Date(t.updatedAt || t.createdAt).toLocaleDateString('ru-RU')}`).join('\n\n')}

---

## ðŸ“Š Statistics

| Metric | Count |
|--------|-------|
| **High Priority** | ${tasks.filter(t => t.priority === 'high').length} |
| **Medium Priority** | ${tasks.filter(t => t.priority === 'medium').length} |
| **Low Priority** | ${tasks.filter(t => t.priority === 'low').length} |
| **Completion Rate** | ${tasks.length > 0 ? Math.round((doneTasks.length / tasks.length) * 100) : 0}% |

---

_Generated by Task Manager AI Agent_
`;

  return summary;
}

// Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ðµ summary Ð² Ñ„Ð°Ð¹Ð»
async function saveSummaryToFile(summary, taskCount) {
  const filename = `task-summary-${Date.now()}.md`;
  const filepath = path.join(SUMMARY_DIR, filename);
  
  await fs.writeFile(filepath, summary, 'utf-8');
  console.error(`âœ… Summary saved: ${filename}`);
  
  return {
    filename,
    filepath,
    relativePath: `task-summaries/${filename}`,
    taskCount,
    timestamp: new Date().toISOString()
  };
}




async function pushToGithub(filename, filepath, taskCount) {
  const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
  const GITHUB_OWNER = process.env.GITHUB_OWNER;
  const GITHUB_REPO = process.env.GITHUB_REPO;
  const GITHUB_BRANCH = process.env.GITHUB_BRANCH || 'main';

  if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
    throw new Error('Missing GitHub credentials: GITHUB_TOKEN, GITHUB_OWNER, GITHUB_REPO');
  }

  try {
    // 1. Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ Git Ñ€ÐµÐ¿Ð¾Ð·Ð¸Ñ‚Ð¾Ñ€Ð¸Ñ
    let isInitialized = false;
    try {
      await execAsync('git rev-parse --git-dir', { timeout: 5000 });
      isInitialized = true;
    } catch {
      console.error('ðŸ”§ Initializing git repository...');
      await execAsync('git init', { timeout: 10000 });
      await execAsync(`git remote add origin https://github.com/${GITHUB_OWNER}/${GITHUB_REPO}.git`, { timeout: 10000 });
    }

    // 2. ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ° git config
    await execAsync('git config user.email "ai-agent@taskmanager.local"', { timeout: 5000 });
    await execAsync('git config user.name "AI Task Manager Agent"', { timeout: 5000 });

    // 3. âœ… Ð˜Ð¡ÐŸÐ ÐÐ’Ð›Ð•ÐÐž: Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ ÑƒÐ½Ð¸ÐºÐ°Ð»ÑŒÐ½Ð¾Ðµ Ð¸Ð¼Ñ Ð²ÐµÑ‚ÐºÐ¸ Ñ timestamp
    const now = new Date();
    const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
    const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, '-'); // HH-MM-SS
    const summaryBranch = `summary/${dateStr}-${timeStr}`;
    
    console.error(`ðŸ”§ Creating summary branch: ${summaryBranch}...`);

    // Ð¡Ð½Ð°Ñ‡Ð°Ð»Ð° Ð¿ÐµÑ€ÐµÐºÐ»ÑŽÑ‡Ð¸ÑÑŒ Ð½Ð° main (Ð±Ð°Ð·Ð¾Ð²Ð°Ñ Ð²ÐµÑ‚ÐºÐ°) Ð¸Ð»Ð¸ ÑÐ¾Ð·Ð´Ð°Ð¹ ÐµÑÐ»Ð¸ Ð½Ðµ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÐµÑ‚
    try {
      // ÐŸÐ¾Ð¿Ñ‹Ñ‚Ð°ÐµÐ¼ÑÑ Ð¿ÐµÑ€ÐµÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒÑÑ Ð½Ð° main ÐµÑÐ»Ð¸ Ð¾Ð½Ð° ÐµÑÑ‚ÑŒ
      const checkoutResult = await execAsync(`git checkout ${GITHUB_BRANCH}`, { timeout: 10000 });
      console.error(`âœ… Switched to branch ${GITHUB_BRANCH}`);
    } catch (mainError) {
      // Ð•ÑÐ»Ð¸ main Ð½Ðµ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÐµÑ‚, ÑÐ¾Ð·Ð´Ð°Ð´Ð¸Ð¼ ÐµÑ‘
      console.error(`ðŸ”§ Branch ${GITHUB_BRANCH} not found, creating...`);
      try {
        await execAsync(`git checkout --orphan ${GITHUB_BRANCH}`, { timeout: 10000 });
        console.error(`âœ… Created orphan branch ${GITHUB_BRANCH}`);
      } catch {
        // Ð˜Ð³Ð½Ð¾Ñ€Ð¸Ñ€ÑƒÐµÐ¼ Ð¾ÑˆÐ¸Ð±ÐºÐ¸, Ð¿Ñ€Ð¾Ð´Ð¾Ð»Ð¶Ð°ÐµÐ¼
      }
    }

    // Ð¢ÐµÐ¿ÐµÑ€ÑŒ ÑÐ¾Ð·Ð´Ð°Ð¹ Ð²ÐµÑ‚ÐºÑƒ Ð´Ð»Ñ summary Ð¾Ñ‚ main
    try {
      // Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ñƒ -B Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¿ÐµÑ€ÐµÐ·Ð°Ð¿Ð¸ÑÐ°Ñ‚ÑŒ ÐµÑÐ»Ð¸ Ð²Ð´Ñ€ÑƒÐ³ Ð²ÐµÑ‚ÐºÐ° ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÐµÑ‚
      await execAsync(`git checkout -B ${summaryBranch}`, { timeout: 10000 });
      console.error(`âœ… Created/switched to summary branch: ${summaryBranch}`);
    } catch (branchError) {
      console.error(`âš ï¸ Branch creation warning: ${branchError.message.substring(0, 80)}`);
    }

    // 4. Ð¡Ð¸Ð½Ñ…Ñ€Ð¾Ð½Ð¸Ð·Ð°Ñ†Ð¸Ñ Ñ GitHub (Ð¾Ð¿Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ð¾)
    if (isInitialized) {
      console.error(`ðŸ”§ Fetching from origin...`);
      try {
        await execAsync('git fetch origin', { timeout: 30000 });
        console.error('âœ… Fetched latest changes');
      } catch (fetchError) {
        console.error(`âš ï¸ Fetch info: ${fetchError.message.substring(0, 80)}`);
      }
    }

    // 5. Ð”Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ñ„Ð°Ð¹Ð»Ð°
    console.error(`ðŸ”§ Adding file: ${filename}`);
    await execAsync(`git add "${filepath}"`, { timeout: 10000 });
    console.error(`âœ… Staged file`);

    // 6. ÐšÐ¾Ð¼Ð¼Ð¸Ñ‚
    const commitMessage = `ðŸ“‹ Task Summary: ${taskCount} tasks (${new Date().toISOString()})`;
    try {
      await execAsync(`git commit -m "${commitMessage}"`, { timeout: 10000 });
      console.error(`âœ… Committed: ${commitMessage}`);
    } catch (commitError) {
      // Ð•ÑÐ»Ð¸ Ð½ÐµÑ‡ÐµÐ³Ð¾ ÐºÐ¾Ð¼Ð¼Ð¸Ñ‚Ð¸Ñ‚ÑŒ, Ð¿Ñ€Ð¾Ð±ÑƒÐµÐ¼ Ð²ÑÑ‘ Ñ€Ð°Ð²Ð½Ð¾ Ð¿ÑƒÑˆÐ¸Ñ‚ÑŒ (Ð¼Ð¾Ð¶ÐµÑ‚ Ð±Ñ‹Ñ‚ÑŒ, Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ñ ÑƒÐ¶Ðµ Ñ‚Ð°Ð¼)
      console.error(`âš ï¸ Commit info: ${commitError.message.substring(0, 80)}`);
    }

    // 7. âœ… Push Ð² summary-Ð²ÐµÑ‚ÐºÑƒ
    const repoUrl = `https://${GITHUB_TOKEN}@github.com/${GITHUB_OWNER}/${GITHUB_REPO}.git`;
    
    console.error(`ðŸ”§ Pushing to ${summaryBranch}...`);
    try {
      // Push Ñ --set-upstream Ð² summary-Ð²ÐµÑ‚ÐºÑƒ
      await execAsync(`git push --set-upstream ${repoUrl} ${summaryBranch}`, { timeout: 30000 });
      console.error(`âœ… Successfully pushed to ${summaryBranch}`);
    } catch (pushError) {
      console.error(`âŒ First push attempt failed: ${pushError.message.substring(0, 100)}`);
      
      // ÐŸÑ€Ð¾Ð±ÑƒÐµÐ¼ Ð±ÐµÐ· --set-upstream
      try {
        console.error(`ðŸ”§ Trying simple push...`);
        await execAsync(`git push ${repoUrl} ${summaryBranch}`, { timeout: 30000 });
        console.error(`âœ… Pushed to GitHub`);
      } catch (simplePushError) {
        throw new Error(`Push failed: ${simplePushError.message.substring(0, 150)}`);
      }
    }

    const fileUrl = `https://github.com/${GITHUB_OWNER}/${GITHUB_REPO}/blob/${summaryBranch}/task-summaries/${filename}`;
    const prUrl = `https://github.com/${GITHUB_OWNER}/${GITHUB_REPO}/compare/${GITHUB_BRANCH}...${summaryBranch}`;

    console.error(`\nâœ… ===== PUSH SUCCESSFUL =====`);
    console.error(`ðŸ“ File: ${filename}`);
    console.error(`ðŸŒ¿ Branch: ${summaryBranch}`);
    console.error(`ðŸ”— URL: ${fileUrl}`);
    console.error(`ðŸ“Œ Create PR: ${prUrl}`);

    return {
      success: true,
      message: `âœ… Successfully pushed ${filename} to GitHub`,
      branch: summaryBranch,
      filename: filename,
      fileUrl: fileUrl,
      prUrl: prUrl,
      commitMessage,
      instructions: `Create PR at: ${prUrl}`
    };
  } catch (error) {
    console.error(`\nâŒ ===== PUSH FAILED =====`);
    console.error(`Error: ${error.message}`);
    throw new Error(`Failed to push to GitHub: ${error.message.substring(0, 200)}`);
  }
}





// MCP Server
const server = new Server(
  { name: "github-task-manager", version: "1.0.0" },
  { capabilities: { tools: {} } }
);

server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: "summarize_tasks_to_file",
        description: "Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÑ‚ Markdown-summary Ð¸Ð· Ð¼Ð°ÑÑÐ¸Ð²Ð° Ð·Ð°Ð´Ð°Ñ‡ Ð¸ ÑÐ¾Ñ…Ñ€Ð°Ð½ÑÐµÑ‚ Ð² Ñ„Ð°Ð¹Ð»",
        inputSchema: {
          type: "object",
          properties: {
            tasks: {
              type: "array",
              description: "ÐœÐ°ÑÑÐ¸Ð² Ð·Ð°Ð´Ð°Ñ‡ Ð¸Ð· Task MCP",
              items: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  title: { type: "string" },
                  description: { type: "string" },
                  priority: { type: "string" },
                  status: { type: "string" },
                  createdAt: { type: "string" },
                  updatedAt: { type: "string" }
                }
              }
            }
          },
          required: ["tasks"]
        }
      },
      {
        name: "push_to_github",
        description: "ÐšÐ¾Ð¼Ð¼Ð¸Ñ‚Ð¸Ñ‚ Ð¸ Ð¿ÑƒÑˆÐ¸Ñ‚ Ñ„Ð°Ð¹Ð» Ñ summary Ð² GitHub Ñ€ÐµÐ¿Ð¾Ð·Ð¸Ñ‚Ð¾Ñ€Ð¸Ð¹",
        inputSchema: {
          type: "object",
          properties: {
            filename: { type: "string", description: "Ð˜Ð¼Ñ Ñ„Ð°Ð¹Ð»Ð° summary" },
            filepath: { type: "string", description: "ÐŸÐ¾Ð»Ð½Ñ‹Ð¹ Ð¿ÑƒÑ‚ÑŒ Ðº Ñ„Ð°Ð¹Ð»Ñƒ" },
            taskCount: { type: "number", description: "ÐšÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ð·Ð°Ð´Ð°Ñ‡" }
          },
          required: ["filename", "filepath", "taskCount"]
        }
      }
    ]
  };
});

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  try {
    switch (name) {
      case "summarize_tasks_to_file": {
        const summary = await generateMarkdownSummary({ tasks: args.tasks || [] });
        const result = await saveSummaryToFile(summary, (args.tasks || []).length);
        
        return {
          content: [{
            type: "text",
            text: JSON.stringify({ success: true, ...result })
          }]
        };
      }

      case "push_to_github": {
        const result = await pushToGithub(args.filename, args.filepath, args.taskCount);
        
        return {
          content: [{
            type: "text",
            text: JSON.stringify({ success: true, ...result })
          }]
        };
      }

      default:
        return {
          content: [{
            type: "text",
            text: JSON.stringify({ success: false, error: `Unknown tool: ${name}` })
          }],
          isError: true
        };
    }
  } catch (error) {
    console.error(`âŒ Tool error (${name}):`, error.message);
    return {
      content: [{
        type: "text",
        text: JSON.stringify({ success: false, error: error.message })
      }],
      isError: true
    };
  }
});

// Ð¡Ñ‚Ð°Ñ€Ñ‚ ÑÐµÑ€Ð²ÐµÑ€Ð°
async function main() {
  await initSummaryDir();
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("âœ… GitHub MCP Server running");
}

main().catch((error) => {
  console.error("Fatal error:", error);
  process.exit(1);
});
